# HookExecutor バックエンド設計書

## 1. モジュール構成

### 1.1 ファイル構成

```
src/hooks/
├── mod.rs               # モジュールエクスポート
├── executor.rs          # HookExecutor実装（本設計書）
├── config.rs            # HookConfig、HookDefinition
└── context.rs           # HookContext、環境変数生成
```

### 1.2 依存関係

```rust
// src/hooks/executor.rs

use anyhow::{Context, Result};
use std::collections::HashMap;
use std::path::PathBuf;
use std::time::Duration;
use tokio::process::Command;
use tokio::time::timeout;
use tracing::{debug, error, info, warn};

use crate::hooks::config::{HookConfig, HookDefinition};
use crate::hooks::context::HookContext;
use crate::types::HookEvent;
```

## 2. データ構造

### 2.1 HookExecutor

```rust
/// フック実行モジュール
#[derive(Clone)]
pub struct HookExecutor {
    /// フック設定
    config: Option<HookConfig>,
    /// フック機能の有効/無効
    enabled: bool,
}

impl HookExecutor {
    /// 新規作成（起動時に設定ファイルを読み込み）
    ///
    /// # 処理フロー
    /// 1. ~/.pomodoro/hooks.json を読み込み
    /// 2. serde_jsonでパース
    /// 3. パース成功時: config設定、enabled=true
    /// 4. パース失敗時: config=None、enabled=false、警告ログ
    /// 5. ファイル不存在時: config=None、enabled=false、情報ログ
    pub fn new() -> Self {
        let config_path = dirs::home_dir()
            .expect("ホームディレクトリが取得できません")
            .join(".pomodoro")
            .join("hooks.json");
        
        if !config_path.exists() {
            info!("フック設定ファイルが見つかりません（フック機能無効）: {:?}", config_path);
            return Self {
                config: None,
                enabled: false,
            };
        }
        
        match std::fs::read_to_string(&config_path) {
            Ok(content) => match serde_json::from_str::<HookConfig>(&content) {
                Ok(config) => {
                    info!("フック設定を読み込みました（{}イベント）", config.hooks.len());
                    Self {
                        config: Some(config),
                        enabled: true,
                    }
                }
                Err(e) => {
                    warn!("フック設定ファイルの解析に失敗しました（フック機能無効）: {:?}", e);
                    Self {
                        config: None,
                        enabled: false,
                    }
                }
            },
            Err(e) => {
                warn!("フック設定ファイルの読み込みに失敗しました（フック機能無効）: {:?}", e);
                Self {
                    config: None,
                    enabled: false,
                }
            }
        }
    }
    
    /// フックを非同期実行（fire-and-forget）
    ///
    /// # 引数
    /// - `context`: フックコンテキスト（イベント種別、タスク情報等）
    ///
    /// # 戻り値
    /// - `Ok(())`: 常に成功（非同期実行のため）
    ///
    /// # 処理フロー
    /// 1. enabled=falseの場合、即座にreturn
    /// 2. イベント名に対応するフックリストを取得
    /// 3. enabled=trueのフックのみフィルタ
    /// 4. フックが0件の場合、即座にreturn
    /// 5. すべてのフックをtokio::spawnで並列非同期実行
    /// 6. 即座にreturn（fire-and-forget）
    pub async fn execute(&self, context: HookContext) -> Result<()> {
        if !self.enabled {
            return Ok(());
        }
        
        let event_name = context.event.as_str();
        let hooks = self.config.as_ref()
            .and_then(|c| c.hooks.get(event_name))
            .cloned()
            .unwrap_or_default();
        
        // enabled=trueのフックのみフィルタ
        let enabled_hooks: Vec<_> = hooks.into_iter()
            .filter(|h| h.enabled)
            .collect();
        
        if enabled_hooks.is_empty() {
            return Ok(());
        }
        
        info!("イベント '{}' のフックを非同期実行開始 ({}件)", 
            event_name, enabled_hooks.len());
        
        // すべてのフックを並列非同期実行
        let global_timeout = self.config.as_ref()
            .map(|c| c.global_timeout)
            .unwrap_or(30);
        
        for hook in enabled_hooks {
            let hook_clone = hook.clone();
            let context_clone = context.clone();
            
            tokio::spawn(async move {
                execute_single_hook(&hook_clone, &context_clone, global_timeout).await;
            });
        }
        
        Ok(())
    }
}
```

## 3. 処理フロー

### 3.1 execute_single_hook関数

```rust
/// 単一フックの実行
///
/// # 引数
/// - `hook`: フック定義
/// - `context`: フックコンテキスト
/// - `global_timeout`: グローバルタイムアウト（秒）
///
/// # 処理フロー
/// 1. バリデーション（スクリプト存在、実行権限）
/// 2. 環境変数設定
/// 3. タイムアウト時間決定（フック個別 > グローバル > デフォルト30秒）
/// 4. tokio::process::Commandでプロセス起動
/// 5. tokio::time::timeoutでタイムアウト監視
/// 6. 実行結果をログに記録
async fn execute_single_hook(
    hook: &HookDefinition,
    context: &HookContext,
    global_timeout: u32,
) {
    let start_time = std::time::Instant::now();
    
    info!("フック '{}' を非同期実行中...", hook.name);
    
    // 1. バリデーション
    if let Err(e) = validate_script(&hook.script) {
        error!("フック '{}' のバリデーションエラー: {:?}", hook.name, e);
        return;
    }
    
    // 2. 環境変数設定
    let mut env_vars = context.to_env_vars();
    env_vars.insert("POMODORO_HOOK_NAME".to_string(), hook.name.clone());
    
    // 3. タイムアウト時間決定
    let timeout_secs = hook.timeout.unwrap_or(global_timeout);
    let timeout_duration = Duration::from_secs(timeout_secs as u64);
    
    // 4. プロセス実行
    let mut cmd = Command::new("/bin/bash");
    cmd.arg(&hook.script);
    cmd.envs(&env_vars);
    cmd.current_dir(
        dirs::home_dir()
            .expect("ホームディレクトリが取得できません")
            .join(".pomodoro")
    );
    cmd.stdout(std::process::Stdio::piped());
    cmd.stderr(std::process::Stdio::piped());
    
    let child = match cmd.spawn() {
        Ok(child) => child,
        Err(e) => {
            error!("フック '{}' の起動に失敗しました: {:?}", hook.name, e);
            return;
        }
    };
    
    // 5. タイムアウト監視
    match timeout(timeout_duration, child.wait_with_output()).await {
        Ok(Ok(output)) => {
            let elapsed = start_time.elapsed();
            
            if output.status.success() {
                info!(
                    "フック '{}' が成功しました (実行時間: {:.2}秒)",
                    hook.name,
                    elapsed.as_secs_f64()
                );
                
                // 標準出力・標準エラー出力をログに記録（最大10KB）
                log_output(&hook.name, &output.stdout, &output.stderr);
            } else {
                error!(
                    "フック '{}' が失敗しました (終了コード: {:?}, 実行時間: {:.2}秒)",
                    hook.name,
                    output.status.code(),
                    elapsed.as_secs_f64()
                );
                log_output(&hook.name, &output.stdout, &output.stderr);
            }
        }
        Ok(Err(e)) => {
            error!("フック '{}' の実行エラー: {:?}", hook.name, e);
        }
        Err(_) => {
            error!(
                "フック '{}' がタイムアウトしました (タイムアウト: {}秒)",
                hook.name,
                timeout_secs
            );
            
            // Note: tokio::process::Childはタイムアウト時に自動的にkillされる
        }
    }
}
```

### 3.2 validate_script関数

```rust
/// スクリプトファイルのバリデーション
///
/// # 検証項目
/// 1. 絶対パスであること
/// 2. ファイルが存在すること
/// 3. 実行権限があること（Unix系のみ）
///
/// # エラー
/// - 絶対パスでない場合
/// - ファイルが存在しない場合
/// - 実行権限がない場合
fn validate_script(script_path: &PathBuf) -> Result<()> {
    // 1. 絶対パスチェック
    if !script_path.is_absolute() {
        anyhow::bail!("スクリプトパスは絶対パスである必要があります: {:?}", script_path);
    }
    
    // 2. ファイル存在チェック
    if !script_path.exists() {
        anyhow::bail!("スクリプトファイルが見つかりません: {:?}", script_path);
    }
    
    // 3. 実行権限チェック（Unix系のみ）
    #[cfg(unix)]
    {
        use std::os::unix::fs::PermissionsExt;
        
        let metadata = std::fs::metadata(script_path)
            .context("スクリプトファイルのメタデータ取得に失敗")?;
        
        let permissions = metadata.permissions();
        let mode = permissions.mode();
        
        // 実行権限ビット（0o111）をチェック
        // 所有者、グループ、その他のいずれかに実行権限があればOK
        if mode & 0o111 == 0 {
            anyhow::bail!("スクリプトに実行権限がありません: {:?}", script_path);
        }
    }
    
    Ok(())
}
```

### 3.3 log_output関数

```rust
/// 標準出力・標準エラー出力をログに記録
///
/// # 引数
/// - `hook_name`: フック名
/// - `stdout`: 標準出力のバイト列
/// - `stderr`: 標準エラー出力のバイト列
///
/// # 処理
/// - 最大10KBまでログに記録
/// - 10KB超過時は切り詰めて "... (truncated)" を追加
/// - 標準出力はDEBUGレベル、標準エラー出力はWARNレベル
fn log_output(hook_name: &str, stdout: &[u8], stderr: &[u8]) {
    const MAX_LOG_SIZE: usize = 10 * 1024; // 10KB
    
    if !stdout.is_empty() {
        let stdout_str = String::from_utf8_lossy(stdout);
        let truncated = if stdout_str.len() > MAX_LOG_SIZE {
            format!("{}... (truncated)", &stdout_str[..MAX_LOG_SIZE])
        } else {
            stdout_str.to_string()
        };
        
        debug!("フック '{}' の標準出力:\n{}", hook_name, truncated);
    }
    
    if !stderr.is_empty() {
        let stderr_str = String::from_utf8_lossy(stderr);
        let truncated = if stderr_str.len() > MAX_LOG_SIZE {
            format!("{}... (truncated)", &stderr_str[..MAX_LOG_SIZE])
        } else {
            stderr_str.to_string()
        };
        
        warn!("フック '{}' の標準エラー出力:\n{}", hook_name, truncated);
    }
}
```

## 4. タイマーエンジンへの統合

### 4.1 TimerEngineへの追加

```rust
// src/daemon/timer.rs

use crate::hooks::executor::HookExecutor;
use crate::hooks::context::HookContext;
use crate::types::HookEvent;

pub struct TimerEngine {
    state: TimerState,
    event_tx: mpsc::UnboundedSender<TimerEvent>,
    hook_executor: Arc<HookExecutor>,  // 追加
}

impl TimerEngine {
    pub fn new(
        config: PomodoroConfig,
        event_tx: mpsc::UnboundedSender<TimerEvent>,
    ) -> Self {
        Self {
            state: TimerState::new(config),
            event_tx,
            hook_executor: Arc::new(HookExecutor::new()),  // 追加
        }
    }
    
    /// フックイベントを発火（非同期・ノンブロッキング）
    fn fire_hook(&self, event: HookEvent) {
        let context = HookContext {
            event,
            phase: self.state.phase,
            task_name: self.state.task_name.clone(),
            duration_secs: self.state.total_duration(),
            elapsed_secs: self.state.total_duration() - self.state.remaining_seconds,
            remaining_secs: self.state.remaining_seconds,
            cycle: self.state.pomodoro_count,
            total_cycles: 4, // 固定値（Phase 1）
            timestamp: chrono::Utc::now(),
            session_id: uuid::Uuid::new_v4(),
        };
        
        // フック実行モジュールに非同期で通知（fire-and-forget）
        let executor = self.hook_executor.clone();
        tokio::spawn(async move {
            if let Err(e) = executor.execute(context).await {
                tracing::error!("フック実行エラー: {:?}", e);
            }
        });
    }
}
```

### 4.2 イベント発火ポイント

```rust
// src/daemon/timer.rs

impl TimerEngine {
    pub fn start(&mut self, params: &StartParams) -> Result<()> {
        // ... 既存処理 ...
        
        // フック発火
        self.fire_hook(HookEvent::WorkStart);
        
        Ok(())
    }
    
    pub fn process_tick(&mut self) -> Result<()> {
        // ... 既存処理 ...
        
        // フェーズ完了時
        if self.state.remaining_seconds == 0 {
            match self.state.phase {
                TimerPhase::Working => {
                    self.fire_hook(HookEvent::WorkEnd);
                    // 次のフェーズへ遷移
                    if should_long_break {
                        self.fire_hook(HookEvent::LongBreakStart);
                    } else {
                        self.fire_hook(HookEvent::BreakStart);
                    }
                }
                TimerPhase::Breaking => {
                    self.fire_hook(HookEvent::BreakEnd);
                    if auto_cycle {
                        self.fire_hook(HookEvent::WorkStart);
                    }
                }
                TimerPhase::LongBreaking => {
                    self.fire_hook(HookEvent::LongBreakEnd);
                    if auto_cycle {
                        self.fire_hook(HookEvent::WorkStart);
                    }
                }
                _ => {}
            }
        }
        
        Ok(())
    }
    
    pub fn pause(&mut self) -> Result<()> {
        // ... 既存処理 ...
        
        self.fire_hook(HookEvent::Pause);
        
        Ok(())
    }
    
    pub fn resume(&mut self) -> Result<()> {
        // ... 既存処理 ...
        
        self.fire_hook(HookEvent::Resume);
        
        Ok(())
    }
    
    pub fn stop(&mut self) -> Result<()> {
        // ... 既存処理 ...
        
        self.fire_hook(HookEvent::Stop);
        
        Ok(())
    }
}
```

## 5. エラーハンドリング

### 5.1 エラー種別と対処

| エラー種別 | HTTPステータス | エラーコード | 対処 |
|-----------|---------------|-------------|------|
| スクリプト不存在 | - | E032 | ログに記録、次のフックを実行 |
| 実行権限なし | - | E033 | ログに記録、次のフックを実行 |
| 実行失敗 | - | E034 | ログに記録、次のフックを実行 |
| タイムアウト | - | E035 | プロセス強制終了、ログに記録 |
| 設定エラー | - | E031 | フック機能を無効化、警告を出力 |

### 5.2 ログ出力例

```
[2026-01-06 10:30:00.123] [INFO] イベント 'work_end' のフックを非同期実行開始 (2件)
[2026-01-06 10:30:00.125] [INFO] フック 'Slack通知' を非同期実行中...
[2026-01-06 10:30:00.127] [INFO] フック 'メール送信' を非同期実行中...
[2026-01-06 10:30:01.345] [INFO] フック 'Slack通知' が成功しました (実行時間: 1.22秒)
[2026-01-06 10:30:01.350] [DEBUG] フック 'Slack通知' の標準出力:
{"ok":true}
[2026-01-06 10:30:11.127] [ERROR] フック 'メール送信' がタイムアウトしました (タイムアウト: 10秒)
```

## 6. テスト方針

### 6.1 単体テスト

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_validate_script_absolute_path() {
        let path = PathBuf::from("/tmp/test.sh");
        // テスト実装
    }
    
    #[test]
    fn test_validate_script_relative_path() {
        let path = PathBuf::from("./test.sh");
        assert!(validate_script(&path).is_err());
    }
    
    #[tokio::test]
    async fn test_execute_single_hook_success() {
        // テスト実装
    }
    
    #[tokio::test]
    async fn test_execute_single_hook_timeout() {
        // テスト実装
    }
}
```

### 6.2 統合テスト

```rust
// tests/hooks_integration_test.rs

#[tokio::test]
async fn test_hook_executor_parallel_execution() {
    // 複数フックの並列実行をテスト
}

#[tokio::test]
async fn test_hook_executor_error_isolation() {
    // 1つのフックの失敗が他のフックに影響しないことをテスト
}
```

---

## 変更履歴

| 日付 | バージョン | 変更内容 | 担当者 |
|:---|:---|:---|:---|
| 2026-01-06 | 1.0.0 | 初版作成 | - |
